```json
{
  "response": "To import and use the utility functions from utils.py in avatarUp.py, follow these steps:\n\n1. Import the required functions from utils.py at the top of avatarUp.py:\n\nfrom utils import read_file_content, write_to_file, read_summary_of_context, write_summary_of_context, get_directory_tree\n\n2. Replace the corresponding function definitions in avatarUp.py with the imported functions from utils.py.\n\n3. Update any calls to these functions in avatarUp.py to use the imported versions.",
  "update_file_path": "/workspaces/greatsun-dev/avatar/avatarUp.py",
  "update_file_contents": "import logging\nimport os\nimport json\nfrom datetime import datetime\nfrom anthropic import Anthropic\nfrom typing import Optional, Dict, Any, List\nimport re\nfrom utils import read_file_content, write_to_file, read_summary_of_context, write_summary_of_context, get_directory_tree\n\n# Constants\nAPI_KEY = os.getenv(\"CLAUDE\")\nLOGS_DIRECTORY = \"avatar/context/conversationLog\"\nSUMMARY_FILE = os.path.join(\"avatar\", \"context\", \"context_summary.json\")\nRESPONSE_INSTRUCTIONS = \"avatar/context/responseInstructions.md\"\nAVATAR_README = \"avatarREADME.md\"\nREADME = \"README.md\"\nMESSAGE_TO_SEND = \"avatar/messageToSend.md\"\nCONTEXT_DIR = \"avatar/context\"\nTERMINAL_COMMANDS_FILE = \"avatar/terminalCommands.txt\"\nCURRENT_RESPONSE_FILE = \"avatar/currentResponse\"\n\n# Ensure directories exist\nos.makedirs(LOGS_DIRECTORY, exist_ok=True)\nos.makedirs(CONTEXT_DIR, exist_ok=True)\nos.makedirs(os.path.dirname(TERMINAL_COMMANDS_FILE), exist_ok=True)\nos.makedirs(os.path.dirname(CURRENT_RESPONSE_FILE), exist_ok=True)\n\ndef setup_logger() -> logging.Logger:\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.INFO)\n    current_date = datetime.now().strftime(\"%Y-%m-%d\")\n    log_file = f\"{LOGS_DIRECTORY}/{current_date}.log\"\n    \n    file_handler = logging.FileHandler(log_file)\n    file_handler.setLevel(logging.INFO)\n    file_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))\n    \n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.ERROR)\n    console_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))\n    \n    logger.addHandler(file_handler)\n    logger.addHandler(console_handler)\n    \n    return logger\n\nlogger = setup_logger()\nclient = Anthropic(api_key=API_KEY)\n\ndef extract_json_from_response(response: str) -> tuple[Optional[dict], str]:\n    json_match = re.search(r'```json\\n(.*?)\\n```', response, re.DOTALL)\n    if json_match:\n        try:\n            json_data = json.loads(json_match.group(1))\n            remaining_text = response[:json_match.start()] + response[json_match.end():]\n            return json_data, remaining_text.strip()\n        except json.JSONDecodeError:\n            logger.error(\"Failed to parse JSON from response\")\n    return None, response\n\ndef process_ai_response(response_json: Optional[Dict[str, Any]], remaining_text: str) -> None:\n    if response_json:\n        # Handle file update\n        file_contents_update = response_json.get(\"update_file_contents\")\n        file_path_update = response_json.get(\"update_file_path\")\n        if file_contents_update and file_path_update:\n            write_to_file(file_path_update, file_contents_update)\n            logger.info(f\"File updated: {file_path_update}\")\n        \n        # Handle context summary update\n        context_summary = response_json.get(\"context_summary\")\n        if context_summary:\n            write_summary_of_context(context_summary)\n            logger.info(\"Context summary updated\")\n        \n        # Handle terminal command\n        terminal_command = response_json.get(\"terminal_command\")\n        if terminal_command:\n            write_to_file(TERMINAL_COMMANDS_FILE, terminal_command + \"\\n\")\n            logger.info(f\"Terminal command written to '{TERMINAL_COMMANDS_FILE}': {terminal_command}\")\n        \n        # Handle response\n        response_text = response_json.get(\"response\", \"\")\n        if remaining_text:\n            response_text += f\"\\n\\nAdditional information:\\n{remaining_text}\"\n        \n        if response_text:\n            write_to_file(CURRENT_RESPONSE_FILE, response_text)\n            logger.info(f\"Response written to '{CURRENT_RESPONSE_FILE}'\")  \n    else:\n        logger.warning(\"No valid JSON found in the response.\")\n        write_to_file(CURRENT_RESPONSE_FILE, remaining_text)\n        logger.info(f\"Full response written to '{CURRENT_RESPONSE_FILE}'\")\n\ndef get_message_content(file_path: str, included_file_content: Optional[str]) -> str:\n    content_parts = [\n        read_file_content(RESPONSE_INSTRUCTIONS),\n        read_file_content(AVATAR_README),\n        read_file_content(README),\n        read_file_content(MESSAGE_TO_SEND),\n        f\"### Summary of context (required)\\n{json.dumps(read_summary_of_context(), indent=2)}\",\n        f\"# Directory structure\\n{json.dumps(get_directory_tree('/workspaces/greatsun-dev'))}\",\n        f\"# Attached file path \\n{file_path}\" if file_path else None,\n        f\"# Attached file contents\\n{included_file_content}\" if included_file_content else None,\n        read_file_content(RESPONSE_INSTRUCTIONS)\n    ]\n    return \"\\n\\n\".join(filter(None, content_parts))\n\ndef main():\n    while True:\n        file_path = input(\"Optional file path (press Enter to skip, 'exit' to quit): \").strip()\n        \n        if file_path.lower() == \"exit\":\n            print(\"Goodbye!\")\n            break\n        \n        included_file_content = read_file_content(file_path) if file_path else None\n        message_content = get_message_content(file_path, included_file_content)\n        \n        write_to_file(os.path.join(CONTEXT_DIR, \"messageSent.txt\"), message_content)\n        \n        try:\n            message = client.messages.create(\n                model=\"claude-3-sonnet-20240229\",\n                max_tokens=4096,\n                messages=[\n                    {\"role\": \"user\", \"content\": message_content}\n                ]\n            )\n            \n            avatar_response = message.content[0].text\n            \n            print(f\"Avatar: {avatar_response}\")\n            logger.info(f\"File: {file_path}\")\n            logger.info(f\"Avatar: {avatar_response}\")\n            \n            write_to_file(os.path.join(CONTEXT_DIR, \"responseReceived.txt\"), avatar_response)\n            \n            response_json, remaining_text = extract_json_from_response(avatar_response)\n            process_ai_response(response_json, remaining_text)\n            \n        except Exception as e:\n            logger.error(f\"Error communicating with Anthropic API: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n",
  "context_summary": [
    {
      "summary": "The script has been updated to extract terminal commands and AI responses from the JSON response and save them to separate files."
    },
    {
      "summary": "A new file called `utils.py` has been created to hold utility functions like file reading/writing, directory tree generation, and context summary handling."
    },
    {
      "summary": "The `avatarUp.py` script has been modified to import and use the utility functions from `utils.py` instead of defining them locally."
    }
  ]
}
```

The main changes made:

1. Imported the required functions from `utils.py` at the top of `avatarUp.py`.
2. Removed the function definitions for `read_file_content`, `write_to_file`, `read_summary_of_context`, `write_summary_of_context`, and `get_directory_tree` from `avatarUp.py` since they are now being imported from `utils.py`.
3. Updated any calls to these functions in `avatarUp.py` to use the imported versions.

The `avatarUp.py` script now uses the utility functions defined in `utils.py` instead of declaring them locally. This helps to keep the code organized and modular, making it easier to maintain and update in the future.